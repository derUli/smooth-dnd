(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SmoothDnD"] = factory();
	else
		root["SmoothDnD"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.dropHandlers = exports.constants = undefined;\n\nvar _container = __webpack_require__(/*! ./src/container */ \"./src/container.js\");\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _constants = __webpack_require__(/*! ./src/constants */ \"./src/constants.js\");\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _dropHandlers = __webpack_require__(/*! ./src/dropHandlers */ \"./src/dropHandlers.js\");\n\nvar dropHandlers = _interopRequireWildcard(_dropHandlers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _container2.default;\nexports.constants = constants;\nexports.dropHandlers = dropHandlers;\n\n//# sourceURL=webpack://SmoothDnD/./index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack://SmoothDnD/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar containerInstance = exports.containerInstance = 'smooth-dnd-container-instance';\nvar containersInDraggable = exports.containersInDraggable = 'smooth-dnd-containers-in-draggable';\n\nvar defaultGroupName = exports.defaultGroupName = '@@smooth-dnd-default-group@@';\nvar wrapperClass = exports.wrapperClass = 'smooth-dnd-draggable-wrapper';\nvar defaultGrabHandleClass = exports.defaultGrabHandleClass = 'smooth-dnd-default-grap-handle';\nvar animationClass = exports.animationClass = 'animated';\nvar translationValue = exports.translationValue = '__smooth_dnd_draggable_translation_value';\nvar visibilityValue = exports.visibilityValue = '__smooth_dnd_draggable_visibility_value';\nvar ghostClass = exports.ghostClass = 'smooth-dnd-ghost';\n\nvar containerClass = exports.containerClass = 'smooth-dnd-container';\n\nvar extraSizeForInsertion = exports.extraSizeForInsertion = 'smooth-dnd-extra-size-for-insertion';\nvar stretcherElementClass = exports.stretcherElementClass = 'smooth-dnd-stretcher-element';\nvar stretcherElementInstance = exports.stretcherElementInstance = 'smooth-dnd-stretcher-instance';\n\nvar isDraggableDetached = exports.isDraggableDetached = 'smoth-dnd-is-draggable-detached';\n\nvar disbaleTouchActions = exports.disbaleTouchActions = 'smooth-dnd-disable-touch-action';\nvar noUserSelectClass = exports.noUserSelectClass = 'smooth-dnd-no-user-select';\n\n//# sourceURL=webpack://SmoothDnD/./src/constants.js?");

/***/ }),

/***/ "./src/container.js":
/*!**************************!*\
  !*** ./src/container.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mediator = __webpack_require__(/*! ./mediator */ \"./src/mediator.js\");\n\nvar _mediator2 = _interopRequireDefault(_mediator);\n\nvar _layoutManager = __webpack_require__(/*! ./layoutManager */ \"./src/layoutManager.js\");\n\nvar _layoutManager2 = _interopRequireDefault(_layoutManager);\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nvar _dropHandlers = __webpack_require__(/*! ./dropHandlers */ \"./src/dropHandlers.js\");\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar defaultOptions = {\n  groupName: null,\n  behaviour: 'move', // move | copy\n  orientation: 'vertical', // vertical | horizontal\n  getChildPayload: null,\n  animationDuration: 250,\n  autoScrollEnabled: true,\n  shouldAcceptDrop: null,\n  shouldAnimateDrop: null\n};\n\nfunction setAnimation(element, add, animationDuration) {\n  if (add) {\n    (0, _utils.addClass)(element, _constants.animationClass);\n    element.style.transitionDuration = animationDuration + 'ms';\n  } else {\n    (0, _utils.removeClass)(element, _constants.animationClass);\n    element.style.removeProperty('transition-duration');\n  }\n}\n\nfunction getContainer(element) {\n  return element ? element[_constants.containerInstance] : null;\n}\n\nfunction initOptions() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOptions;\n\n  return Object.assign({}, defaultOptions, props);\n}\n\nfunction isDragRelevant(_ref) {\n  var element = _ref.element,\n      options = _ref.options;\n\n  return function (sourceContainer, payload) {\n    if (options.shouldAcceptDrop) {\n      return options.shouldAcceptDrop(sourceContainer.getOptions(), payload);\n    }\n    var sourceOptions = sourceContainer.getOptions();\n    if (options.behaviour === 'copy') return false;\n\n    var parentWrapper = (0, _utils.getParent)(element, '.' + _constants.wrapperClass);\n    if (parentWrapper === sourceContainer.element) {\n      return false;\n    }\n\n    if (sourceContainer.element === element) return true;\n    if (sourceOptions.groupName && sourceOptions.groupName === options.groupName) return true;\n\n    return false;\n  };\n}\n\nfunction wrapChild(child) {\n  if (SmoothDnD.wrapChild) {\n    return SmoothDnD.wrapChild(child);\n  }\n  var div = global.document.createElement('div');\n  div.className = '' + _constants.wrapperClass;\n  child.parentElement.insertBefore(div, child);\n  div.appendChild(child);\n  return div;\n}\n\nfunction wrapChildren(element) {\n  var draggables = [];\n  Array.prototype.map.call(element.children, function (child) {\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      var wrapper = child;\n      if (!(0, _utils.hasClass)(child, _constants.wrapperClass)) {\n        wrapper = wrapChild(child);\n      }\n      wrapper[_constants.containersInDraggable] = [];\n      wrapper[_constants.translationValue] = 0;\n      draggables.push(wrapper);\n    } else {\n      if (typeof element.removeChild === \"function\") {\n        element.removeChild(child);\n      }\n    }\n  });\n  return draggables;\n}\n\nfunction unwrapChildren(element) {\n  Array.prototype.map.call(element.children, function (child) {\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      var wrapper = child;\n      if ((0, _utils.hasClass)(child, _constants.wrapperClass)) {\n        element.insertBefore(wrapper, wrapChild.firstElementChild);\n        element.removeChild(wrapper);\n      }\n    }\n  });\n}\n\nfunction findDraggebleAtPos(_ref2) {\n  var layout = _ref2.layout;\n\n  var find = function find(draggables, pos, startIndex, endIndex) {\n    var withRespectToMiddlePoints = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    if (endIndex < startIndex) {\n      return startIndex;\n    }\n    // binary serach draggable\n    if (startIndex === endIndex) {\n      var _layout$getBeginEnd = layout.getBeginEnd(draggables[startIndex]),\n          begin = _layout$getBeginEnd.begin,\n          end = _layout$getBeginEnd.end;\n      // mouse pos is inside draggable\n      // now decide which index to return\n\n\n      if (pos > begin && pos <= end) {\n        if (withRespectToMiddlePoints) {\n          return pos < (end + begin) / 2 ? startIndex : startIndex + 1;\n        } else {\n          return startIndex;\n        }\n      } else {\n        return null;\n      }\n    } else {\n      var middleIndex = Math.floor((endIndex + startIndex) / 2);\n\n      var _layout$getBeginEnd2 = layout.getBeginEnd(draggables[middleIndex]),\n          _begin = _layout$getBeginEnd2.begin,\n          _end = _layout$getBeginEnd2.end;\n\n      if (pos < _begin) {\n        return find(draggables, pos, startIndex, middleIndex - 1, withRespectToMiddlePoints);\n      } else if (pos > _end) {\n        return find(draggables, pos, middleIndex + 1, endIndex, withRespectToMiddlePoints);\n      } else {\n        if (withRespectToMiddlePoints) {\n          return pos < (_end + _begin) / 2 ? middleIndex : middleIndex + 1;\n        } else {\n          return middleIndex;\n        }\n      }\n    }\n  };\n\n  return function (draggables, pos) {\n    var withRespectToMiddlePoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return find(draggables, pos, 0, draggables.length - 1, withRespectToMiddlePoints);\n  };\n}\n\nfunction resetDraggables(_ref3) {\n  var element = _ref3.element,\n      draggables = _ref3.draggables,\n      layout = _ref3.layout,\n      options = _ref3.options;\n\n  return function () {\n    draggables.forEach(function (p) {\n      setAnimation(p, false);\n      layout.setTranslation(p, 0);\n      layout.setVisibility(p, true);\n      p[_constants.containersInDraggable] = [];\n    });\n\n    if (element[_constants.stretcherElementInstance]) {\n      element[_constants.stretcherElementInstance].parentNode.removeChild(element[_constants.stretcherElementInstance]);\n      element[_constants.stretcherElementInstance] = null;\n    }\n  };\n}\n\nfunction setTargetContainer(draggableInfo, element) {\n  var set = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (element && set) {\n    draggableInfo.targetElement = element;\n  } else {\n    if (draggableInfo.targetElement === element) {\n      draggableInfo.targetElement = null;\n    }\n  }\n}\n\nfunction handleDrop(_ref4) {\n  var element = _ref4.element,\n      draggables = _ref4.draggables,\n      layout = _ref4.layout,\n      options = _ref4.options;\n\n  var draggablesReset = resetDraggables({ element: element, draggables: draggables, layout: layout, options: options });\n  var dropHandler = (SmoothDnD.dropHandler || _dropHandlers.domDropHandler)({ element: element, draggables: draggables, layout: layout, options: options });\n  return function (draggableInfo, _ref5) {\n    var addedIndex = _ref5.addedIndex,\n        removedIndex = _ref5.removedIndex;\n\n    draggablesReset();\n    // if drop zone is valid => complete drag else do nothing everything will be reverted by draggablesReset()\n    if (draggableInfo.targetElement || options.removeOnDropOut) {\n      var actualAddIndex = addedIndex !== null ? removedIndex !== null && removedIndex < addedIndex ? addedIndex - 1 : addedIndex : null;\n      var dropHandlerParams = {\n        removedIndex: removedIndex,\n        addedIndex: actualAddIndex,\n        payload: draggableInfo.payload,\n        droppedElement: draggableInfo.element.firstElementChild\n      };\n      dropHandler(dropHandlerParams, options.onDrop);\n    }\n  };\n}\n\nfunction getContainerProps(element, initialOptions) {\n  var options = initOptions(initialOptions);\n  var draggables = wrapChildren(element, options.orientation, options.animationDuration);\n  // set flex classes before layout is inited for scroll listener\n  (0, _utils.addClass)(element, _constants.containerClass + ' ' + options.orientation);\n  var layout = (0, _layoutManager2.default)(element, options.orientation, options.animationDuration);\n  return {\n    element: element,\n    draggables: draggables,\n    options: options,\n    layout: layout\n  };\n}\n\nfunction getRelaventParentContainer(container, relevantContainers) {\n  var current = container.element;\n  while (current) {\n    var containerOfParentElement = getContainer(current.parentElement);\n    if (containerOfParentElement && relevantContainers.indexOf(containerOfParentElement) > -1) {\n      return {\n        container: containerOfParentElement,\n        draggable: current\n      };\n    }\n    current = current.parentElement;\n  }\n\n  return null;\n}\n\nfunction registerToParentContainer(container, relevantContainers) {\n  var parentInfo = getRelaventParentContainer(container, relevantContainers);\n  if (parentInfo) {\n    parentInfo.container.getChildContainers().push(container);\n    container.setParentContainer(parentInfo.container);\n    //current should be draggable\n    parentInfo.draggable[_constants.containersInDraggable].push(container);\n  }\n}\n\nfunction getRemovedItem(_ref6) {\n  var draggables = _ref6.draggables,\n      element = _ref6.element,\n      options = _ref6.options;\n\n  var prevRemovedIndex = null;\n  return function (_ref7) {\n    var draggableInfo = _ref7.draggableInfo,\n        dragResult = _ref7.dragResult;\n\n    var removedIndex = prevRemovedIndex;\n    if (prevRemovedIndex == null && draggableInfo.container.element === element && options.behaviour !== 'copy') {\n      removedIndex = prevRemovedIndex = draggableInfo.elementIndex;\n    }\n\n    return { removedIndex: removedIndex };\n  };\n}\n\nfunction setRemovedItemVisibilty(_ref8) {\n  var draggables = _ref8.draggables,\n      layout = _ref8.layout;\n\n  return function (_ref9) {\n    var draggableInfo = _ref9.draggableInfo,\n        dragResult = _ref9.dragResult;\n\n    if (dragResult.removedIndex !== null) {\n      layout.setVisibility(draggables[dragResult.removedIndex], false);\n    }\n  };\n}\n\nfunction getPosition(_ref10) {\n  var element = _ref10.element,\n      layout = _ref10.layout;\n\n  return function (_ref11) {\n    var draggableInfo = _ref11.draggableInfo;\n\n    return {\n      pos: !getContainer(element).isPosInChildContainer() ? layout.getPosition(draggableInfo.position) : null\n    };\n  };\n}\n\nfunction notifyParentOnPositionCapture(_ref12) {\n  var element = _ref12.element;\n\n  var isCaptured = false;\n  return function (_ref13) {\n    var draggableInfo = _ref13.draggableInfo,\n        dragResult = _ref13.dragResult;\n\n    if (getContainer(element).getParentContainer() && isCaptured !== (dragResult.pos !== null)) {\n      isCaptured = dragResult.pos !== null;\n      getContainer(element).getParentContainer().onChildPositionCaptured(isCaptured);\n    }\n  };\n}\n\nfunction getElementSize(_ref14) {\n  var layout = _ref14.layout;\n\n  var elementSize = null;\n  return function (_ref15) {\n    var draggableInfo = _ref15.draggableInfo,\n        dragResult = _ref15.dragResult;\n\n    if (dragResult.pos === null) {\n      return elementSize = null;\n    } else {\n      elementSize = elementSize || layout.getSize(draggableInfo.element);\n    }\n    return { elementSize: elementSize };\n  };\n}\n\nfunction handleTargetContainer(_ref16) {\n  var element = _ref16.element;\n\n  return function (_ref17) {\n    var draggableInfo = _ref17.draggableInfo,\n        dragResult = _ref17.dragResult;\n\n    setTargetContainer(draggableInfo, element, !!dragResult.pos);\n  };\n}\n\nfunction getDragInsertionIndex(_ref18) {\n  var draggables = _ref18.draggables,\n      layout = _ref18.layout;\n\n  var findDraggable = findDraggebleAtPos({ layout: layout });\n  return function (_ref19) {\n    var _ref19$dragResult = _ref19.dragResult,\n        shadowBeginEnd = _ref19$dragResult.shadowBeginEnd,\n        pos = _ref19$dragResult.pos;\n\n    if (!shadowBeginEnd) {\n      var index = findDraggable(draggables, pos, true);\n      return index !== null ? index : draggables.length;\n    } else {\n      if (shadowBeginEnd.begin + shadowBeginEnd.beginAdjustment <= pos && shadowBeginEnd.end >= pos) {\n        // position inside ghost\n        return null;\n      }\n    }\n\n    if (pos < shadowBeginEnd.begin + shadowBeginEnd.beginAdjustment) {\n      return findDraggable(draggables, pos);\n    } else if (pos > shadowBeginEnd.end) {\n      return findDraggable(draggables, pos) + 1;\n    } else {\n      return draggables.length;\n    }\n  };\n}\n\nfunction getDragInsertionIndexForDropZone(_ref20) {\n  var draggables = _ref20.draggables,\n      layout = _ref20.layout;\n\n  return function (_ref21) {\n    var pos = _ref21.dragResult.pos;\n\n    return pos !== null ? { addedIndex: 0 } : { addedIndex: null };\n  };\n}\n\nfunction getShadowBeginEndForDropZone(_ref22) {\n  var draggables = _ref22.draggables,\n      layout = _ref22.layout;\n\n  var prevAddedIndex = null;\n  return function (_ref23) {\n    var addedIndex = _ref23.dragResult.addedIndex;\n\n    if (addedIndex !== prevAddedIndex) {\n      prevAddedIndex = addedIndex;\n\n      var _layout$getBeginEndOf = layout.getBeginEndOfContainer(),\n          begin = _layout$getBeginEndOf.begin,\n          end = _layout$getBeginEndOf.end;\n\n      return {\n        shadowBeginEnd: {\n          rect: layout.getTopLeftOfElementBegin(begin, end)\n        }\n      };\n    }\n  };\n}\n\nfunction invalidateShadowBeginEndIfNeeded(params) {\n  var shadowBoundsGetter = getShadowBeginEnd(params);\n  return function (_ref24) {\n    var draggableInfo = _ref24.draggableInfo,\n        dragResult = _ref24.dragResult;\n\n    if (draggableInfo.invalidateShadow) {\n      return shadowBoundsGetter({ draggableInfo: draggableInfo, dragResult: dragResult });\n    }\n    return null;\n  };\n}\n\nfunction getNextAddedIndex(params) {\n  var getIndexForPos = getDragInsertionIndex(params);\n  return function (_ref25) {\n    var dragResult = _ref25.dragResult;\n\n    var index = null;\n    if (dragResult.pos !== null) {\n      index = getIndexForPos({ dragResult: dragResult });\n      if (index === null) {\n        index = dragResult.addedIndex;\n      }\n    }\n    return {\n      addedIndex: index\n    };\n  };\n}\n\nfunction resetShadowAdjustment() {\n  var lastAddedIndex = null;\n  return function (_ref26) {\n    var _ref26$dragResult = _ref26.dragResult,\n        addedIndex = _ref26$dragResult.addedIndex,\n        shadowBeginEnd = _ref26$dragResult.shadowBeginEnd;\n\n    if (addedIndex !== lastAddedIndex && lastAddedIndex !== null && shadowBeginEnd) {\n      shadowBeginEnd.beginAdjustment = 0;\n    }\n    lastAddedIndex = addedIndex;\n  };\n}\n\nfunction handleInsertionSizeChange(_ref27) {\n  var element = _ref27.element,\n      draggables = _ref27.draggables,\n      layout = _ref27.layout,\n      options = _ref27.options;\n\n  var strectherElement = null;\n  return function (_ref28) {\n    var _ref28$dragResult = _ref28.dragResult,\n        addedIndex = _ref28$dragResult.addedIndex,\n        removedIndex = _ref28$dragResult.removedIndex,\n        elementSize = _ref28$dragResult.elementSize;\n\n    if (removedIndex === null) {\n      if (addedIndex !== null) {\n        if (!strectherElement) {\n          var containerBeginEnd = layout.getBeginEndOfContainer();\n          containerBeginEnd.end = containerBeginEnd.begin + layout.getSize(element);\n          var hasScrollBar = layout.getScrollSize(element) > layout.getSize(element);\n          var containerEnd = hasScrollBar ? containerBeginEnd.begin + layout.getScrollSize(element) - layout.getScrollValue(element) : containerBeginEnd.end;\n          var lastDraggableEnd = draggables.length > 0 ? layout.getBeginEnd(draggables[draggables.length - 1]).end - draggables[draggables.length - 1][_constants.translationValue] : containerBeginEnd.begin;\n          if (lastDraggableEnd + elementSize > containerEnd) {\n            strectherElement = global.document.createElement('div');\n            strectherElement.className = _constants.stretcherElementClass + ' ' + options.orientation;\n            var stretcherSize = elementSize + lastDraggableEnd - containerEnd;\n            layout.setSize(strectherElement.style, stretcherSize + 'px');\n            element.appendChild(strectherElement);\n            element[_constants.stretcherElementInstance] = strectherElement;\n            return {\n              containerBoxChanged: true\n            };\n          }\n        }\n      } else {\n        if (strectherElement) {\n          layout.setTranslation(strectherElement, 0);\n          var toRemove = strectherElement;\n          strectherElement = null;\n          element.removeChild(toRemove);\n          element[_constants.stretcherElementInstance] = null;\n          return {\n            containerBoxChanged: true\n          };\n        }\n      }\n    }\n  };\n}\n\nfunction calculateTranslations(_ref29) {\n  var element = _ref29.element,\n      draggables = _ref29.draggables,\n      layout = _ref29.layout;\n\n  var prevAddedIndex = null;\n  var prevRemovedIndex = null;\n  return function (_ref30) {\n    var _ref30$dragResult = _ref30.dragResult,\n        addedIndex = _ref30$dragResult.addedIndex,\n        removedIndex = _ref30$dragResult.removedIndex,\n        elementSize = _ref30$dragResult.elementSize;\n\n    if (addedIndex !== prevAddedIndex || removedIndex !== prevRemovedIndex) {\n      for (var index = 0; index < draggables.length; index++) {\n        if (index !== removedIndex) {\n          var draggable = draggables[index];\n          var translate = 0;\n          if (removedIndex !== null && removedIndex < index) {\n            translate -= layout.getSize(draggables[removedIndex]);\n          }\n          if (addedIndex !== null && addedIndex <= index) {\n            translate += elementSize;\n          }\n          layout.setTranslation(draggable, translate);\n        }\n      }\n\n      prevAddedIndex = addedIndex;\n      prevRemovedIndex = removedIndex;\n\n      return { addedIndex: addedIndex, removedIndex: removedIndex };\n    }\n  };\n}\n\nfunction getShadowBeginEnd(_ref31) {\n  var draggables = _ref31.draggables,\n      layout = _ref31.layout;\n\n  var prevAddedIndex = null;\n  return function (_ref32) {\n    var draggableInfo = _ref32.draggableInfo,\n        dragResult = _ref32.dragResult;\n    var addedIndex = dragResult.addedIndex,\n        removedIndex = dragResult.removedIndex,\n        elementSize = dragResult.elementSize,\n        pos = dragResult.pos,\n        shadowBeginEnd = dragResult.shadowBeginEnd;\n\n    if (pos !== null) {\n      if (addedIndex !== null && (draggableInfo.invalidateShadow || addedIndex !== prevAddedIndex)) {\n        if (prevAddedIndex) prevAddedIndex = addedIndex;\n        var beforeIndex = addedIndex - 1;\n        var begin = 0;\n        var afterBounds = null;\n        var beforeBounds = null;\n        if (beforeIndex === removedIndex) {\n          beforeIndex--;\n        }\n        if (beforeIndex > -1) {\n          var beforeSize = layout.getSize(draggables[beforeIndex]);\n          beforeBounds = layout.getBeginEnd(draggables[beforeIndex]);\n          if (elementSize < beforeSize) {\n            var threshold = (beforeSize - elementSize) / 2;\n            begin = beforeBounds.end - threshold;\n          } else {\n            begin = beforeBounds.end;\n          }\n        } else {\n          beforeBounds = { end: layout.getBeginEndOfContainer().begin };\n        }\n\n        var end = 10000;\n        var afterIndex = addedIndex;\n        if (afterIndex === removedIndex) {\n          afterIndex++;\n        }\n        if (afterIndex < draggables.length) {\n          var afterSize = layout.getSize(draggables[afterIndex]);\n          afterBounds = layout.getBeginEnd(draggables[afterIndex]);\n\n          if (elementSize < afterSize) {\n            var _threshold = (afterSize - elementSize) / 2;\n            end = afterBounds.begin + _threshold;\n          } else {\n            end = afterBounds.begin;\n          }\n        } else {\n          afterBounds = { begin: layout.getContainerRectangles().end };\n        }\n\n        var shadowRectTopLeft = beforeBounds && afterBounds ? layout.getTopLeftOfElementBegin(beforeBounds.end, afterBounds.begin) : null;\n\n        return {\n          shadowBeginEnd: {\n            begin: begin,\n            end: end,\n            rect: shadowRectTopLeft,\n            beginAdjustment: shadowBeginEnd ? shadowBeginEnd.beginAdjustment : 0\n          }\n        };\n      } else {\n        return null;\n      }\n    } else {\n      prevAddedIndex = null;\n      return {\n        shadowBeginEnd: null\n      };\n    }\n  };\n}\n\nfunction handleFirstInsertShadowAdjustment() {\n  var lastAddedIndex = null;\n  return function (_ref33) {\n    var _ref33$dragResult = _ref33.dragResult,\n        pos = _ref33$dragResult.pos,\n        addedIndex = _ref33$dragResult.addedIndex,\n        shadowBeginEnd = _ref33$dragResult.shadowBeginEnd,\n        invalidateShadow = _ref33.draggableInfo.invalidateShadow;\n\n    if (pos !== null) {\n      if (addedIndex != null && lastAddedIndex === null) {\n        if (pos < shadowBeginEnd.begin) {\n          var beginAdjustment = pos - shadowBeginEnd.begin - 5;\n          shadowBeginEnd.beginAdjustment = beginAdjustment;\n        }\n        lastAddedIndex = addedIndex;\n      }\n    } else {\n      lastAddedIndex = null;\n    }\n  };\n}\n\nfunction fireDragEnterLeaveEvents(_ref34) {\n  var options = _ref34.options;\n\n  var wasDragIn = false;\n  return function (_ref35) {\n    var pos = _ref35.dragResult.pos;\n\n    var isDragIn = !!pos;\n    if (isDragIn !== wasDragIn) {\n      wasDragIn = isDragIn;\n      if (isDragIn) {\n        options.onDragEnter && options.onDragEnter();\n      } else {\n        options.onDragLeave && options.onDragLeave();\n        return {\n          dragLeft: true\n        };\n      }\n    }\n  };\n}\n\nfunction fireOnDropReady(_ref36) {\n  var options = _ref36.options;\n\n  var lastAddedIndex = null;\n  return function (_ref37) {\n    var _ref37$dragResult = _ref37.dragResult,\n        addedIndex = _ref37$dragResult.addedIndex,\n        removedIndex = _ref37$dragResult.removedIndex,\n        _ref37$draggableInfo = _ref37.draggableInfo,\n        payload = _ref37$draggableInfo.payload,\n        element = _ref37$draggableInfo.element;\n\n    if (options.onDropReady && lastAddedIndex !== addedIndex) {\n      lastAddedIndex = addedIndex;\n      var adjustedAddedIndex = addedIndex;\n\n      if (removedIndex !== null && addedIndex > removedIndex) {\n        adjustedAddedIndex--;\n      }\n\n      options.onDropReady({ addedIndex: adjustedAddedIndex, removedIndex: removedIndex, payload: payload, element: element.firstElementChild });\n    }\n  };\n}\n\nfunction getDragHandler(params) {\n  if (params.options.behaviour === 'drop-zone') {\n    // sorting is disabled in container, addedIndex will always be 0 if dropped in\n    return compose(params)(getRemovedItem, setRemovedItemVisibilty, getPosition, notifyParentOnPositionCapture, getElementSize, handleTargetContainer, getDragInsertionIndexForDropZone, getShadowBeginEndForDropZone, fireDragEnterLeaveEvents, fireOnDropReady);\n  } else {\n    return compose(params)(getRemovedItem, setRemovedItemVisibilty, getPosition, notifyParentOnPositionCapture, getElementSize, handleTargetContainer, invalidateShadowBeginEndIfNeeded, getNextAddedIndex, resetShadowAdjustment, handleInsertionSizeChange, calculateTranslations, getShadowBeginEnd, handleFirstInsertShadowAdjustment, fireDragEnterLeaveEvents, fireOnDropReady);\n  }\n}\n\nfunction getDefaultDragResult() {\n  return {\n    addedIndex: null,\n    removedIndex: null,\n    elementSize: null,\n    pos: null,\n    shadowBeginEnd: null\n  };\n}\n\nfunction compose(params) {\n  return function () {\n    for (var _len = arguments.length, functions = Array(_len), _key = 0; _key < _len; _key++) {\n      functions[_key] = arguments[_key];\n    }\n\n    var hydratedFunctions = functions.map(function (p) {\n      return p(params);\n    });\n    var result = null;\n    return function (draggableInfo) {\n      result = hydratedFunctions.reduce(function (dragResult, fn) {\n        return Object.assign(dragResult, fn({ draggableInfo: draggableInfo, dragResult: dragResult }));\n      }, result || getDefaultDragResult());\n      return result;\n    };\n  };\n}\n\n// Container definition begin\nfunction Container(element) {\n  return function (options) {\n    var dragResult = null;\n    var lastDraggableInfo = null;\n    var props = getContainerProps(element, options);\n    var dragHandler = getDragHandler(props);\n    var dropHandler = handleDrop(props);\n    var parentContainer = null;\n    var posIsInChildContainer = false;\n    var childContainers = [];\n\n    function processLastDraggableInfo() {\n      if (lastDraggableInfo !== null) {\n        lastDraggableInfo.invalidateShadow = true;\n        dragResult = dragHandler(lastDraggableInfo);\n        lastDraggableInfo.invalidateShadow = false;\n      }\n    }\n\n    function onChildPositionCaptured(isCaptured) {\n      posIsInChildContainer = isCaptured;\n      if (parentContainer) {\n        parentContainer.onChildPositionCaptured(isCaptured);\n        if (lastDraggableInfo) {\n          dragResult = dragHandler(lastDraggableInfo);\n        }\n      }\n    }\n\n    function _setDraggables(draggables, element, options) {\n      var newDraggables = wrapChildren(element, options.orientation, options.animationDuration);\n      for (var i = 0; i < newDraggables.length; i++) {\n        draggables[i] = newDraggables[i];\n      }\n\n      for (var _i = 0; _i < draggables.length - newDraggables.length; _i++) {\n        draggables.pop();\n      }\n    }\n\n    function prepareDrag(container, relevantContainers) {\n      var element = container.element;\n      var draggables = props.draggables;\n      var options = container.getOptions();\n      _setDraggables(draggables, element, options);\n      container.layout.invalidateRects();\n      registerToParentContainer(container, relevantContainers);\n      draggables.forEach(function (p) {\n        return setAnimation(p, true, options.animationDuration);\n      });\n    }\n\n    props.layout.setScrollListener(function () {\n      processLastDraggableInfo();\n    });\n\n    function handleDragLeftDeferedTranslation() {\n      if (dragResult.dragLeft && props.options.behaviour !== 'drop-zone') {\n        dragResult.dragLeft = false;\n        setTimeout(function () {\n          if (dragResult) calculateTranslations(props)({ dragResult: dragResult });\n        }, 20);\n      }\n    }\n\n    function dispose(container) {\n      unwrapChildren(container.element);\n    }\n\n    return {\n      element: element,\n      draggables: props.draggables,\n      isDragRelevant: isDragRelevant(props),\n      getScale: props.layout.getContainerScale,\n      layout: props.layout,\n      getChildContainers: function getChildContainers() {\n        return childContainers;\n      },\n      onChildPositionCaptured: onChildPositionCaptured,\n      dispose: dispose,\n      prepareDrag: prepareDrag,\n      isPosInChildContainer: function isPosInChildContainer() {\n        return posIsInChildContainer;\n      },\n      handleDrag: function handleDrag(draggableInfo) {\n        lastDraggableInfo = draggableInfo;\n        dragResult = dragHandler(draggableInfo);\n        handleDragLeftDeferedTranslation();\n        return dragResult;\n      },\n      handleDrop: function handleDrop(draggableInfo) {\n        lastDraggableInfo = null;\n        onChildPositionCaptured(false);\n        dragHandler = getDragHandler(props);\n        dropHandler(draggableInfo, dragResult);\n        dragResult = null;\n        parentContainer = null;\n        childContainers = [];\n      },\n      getDragResult: function getDragResult() {\n        return dragResult;\n      },\n      getTranslateCalculator: function getTranslateCalculator() {\n        return calculateTranslations(props).apply(undefined, arguments);\n      },\n      setParentContainer: function setParentContainer(e) {\n        parentContainer = e;\n      },\n      getParentContainer: function getParentContainer() {\n        return parentContainer;\n      },\n      onTranslated: function onTranslated() {\n        processLastDraggableInfo();\n      },\n      getOptions: function getOptions() {\n        return props.options;\n      },\n      setDraggables: function setDraggables() {\n        _setDraggables(props.draggables, element, props.options);\n      }\n    };\n  };\n}\n\nvar options = {\n  behaviour: 'move',\n  groupName: 'bla bla', // if not defined => container will not interfere with other containers\n  orientation: 'vertical',\n  dragHandleSelector: null,\n  nonDragAreaSelector: 'some selector',\n  dragBeginDelay: 0,\n  animationDuration: 180,\n  autoScrollEnabled: true,\n  lockAxis: true,\n  dragClass: null,\n  dropClass: null,\n  onDragStart: function onDragStart(index, payload) {},\n  onDrop: function onDrop(_ref38) {\n    var removedIndex = _ref38.removedIndex,\n        addedIndex = _ref38.addedIndex,\n        payload = _ref38.payload,\n        element = _ref38.element;\n  },\n  getChildPayload: function getChildPayload(index) {\n    return null;\n  },\n  shouldAnimateDrop: function shouldAnimateDrop(sourceContainerOptions, payload) {\n    return true;\n  },\n  shouldAcceptDrop: function shouldAcceptDrop(sourceContainerOptions, payload) {\n    return true;\n  },\n  onDragEnter: function onDragEnter() {},\n  onDragLeave: function onDragLeave() {},\n  onDropReady: function onDropReady(_ref39) {\n    var removedIndex = _ref39.removedIndex,\n        addedIndex = _ref39.addedIndex,\n        payload = _ref39.payload,\n        element = _ref39.element;\n  }\n};\n\n// exported part of container\nfunction SmoothDnD(element, options) {\n  var containerIniter = Container(element);\n  var container = containerIniter(options);\n  element[_constants.containerInstance] = container;\n  _mediator2.default.register(container);\n  return {\n    dispose: function dispose() {\n      _mediator2.default.unregister(container);\n      container.layout.dispose();\n      container.dispose(container);\n    }\n  };\n}\n\nexports.default = SmoothDnD;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/container.js?");

/***/ }),

/***/ "./src/dragscroller.js":
/*!*****************************!*\
  !*** ./src/dragscroller.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar maxSpeed = 1500; // px/s\nvar minSpeed = 20; // px/s\n\nfunction addScrollValue(element, axis, value) {\n\tif (element) {\n\t\tif (element !== window) {\n\t\t\tif (axis === 'x') {\n\t\t\t\telement.scrollLeft += value;\n\t\t\t} else {\n\t\t\t\telement.scrollTop += value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (axis === 'x') {\n\t\t\t\telement.scrollBy(value, 0);\n\t\t\t} else {\n\t\t\t\telement.scrollBy(0, value);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar createAnimator = function createAnimator(element) {\n\tvar axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';\n\n\tvar isAnimating = false;\n\tvar request = null;\n\tvar startTime = null;\n\tvar direction = null;\n\tvar speed = null;\n\n\tfunction animate(_direction, _speed) {\n\t\tdirection = _direction;\n\t\tspeed = _speed;\n\t\tisAnimating = true;\n\t\tif (isAnimating) {\n\t\t\tstart();\n\t\t}\n\t}\n\n\tfunction start() {\n\t\tif (request === null) {\n\t\t\trequest = requestAnimationFrame(function (timestamp) {\n\t\t\t\tif (startTime === null) {\n\t\t\t\t\tstartTime = timestamp;\n\t\t\t\t}\n\t\t\t\tvar timeDiff = timestamp - startTime;\n\t\t\t\tstartTime = timestamp;\n\t\t\t\tvar distanceDiff = timeDiff / 1000 * speed;\n\t\t\t\tdistanceDiff = direction === 'begin' ? 0 - distanceDiff : distanceDiff;\n\t\t\t\taddScrollValue(element, axis, distanceDiff);\n\t\t\t\trequest = null;\n\t\t\t\tstart();\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction stop() {\n\t\tif (isAnimating) {\n\t\t\tcancelAnimationFrame(request);\n\t\t\tisAnimating = false;\n\t\t\tstartTime = null;\n\t\t\trequest = null;\n\t\t}\n\t}\n\n\treturn {\n\t\tanimate: animate,\n\t\tstop: stop\n\t};\n};\n\nfunction getAutoScrollInfo(position, scrollableInfo) {\n\tvar _scrollableInfo$rect = scrollableInfo.rect,\n\t    left = _scrollableInfo$rect.left,\n\t    right = _scrollableInfo$rect.right,\n\t    top = _scrollableInfo$rect.top,\n\t    bottom = _scrollableInfo$rect.bottom;\n\tvar x = position.x,\n\t    y = position.y;\n\n\tif (x < left || x > right || y < top || y > bottom) {\n\t\treturn null;\n\t}\n\n\tvar begin = void 0;\n\tvar end = void 0;\n\tvar pos = void 0;\n\tif (scrollableInfo.axis === 'x') {\n\t\tbegin = left;\n\t\tend = right;\n\t\tpos = x;\n\t} else {\n\t\tbegin = top;\n\t\tend = bottom;\n\t\tpos = y;\n\t}\n\n\tvar moveDistance = 100;\n\tif (end - pos < moveDistance) {\n\t\treturn {\n\t\t\tdirection: 'end',\n\t\t\tspeedFactor: (moveDistance - (end - pos)) / moveDistance\n\t\t};\n\t} else if (pos - begin < moveDistance) {\n\t\t// console.log(pos - begin);\n\t\treturn {\n\t\t\tdirection: 'begin',\n\t\t\tspeedFactor: (moveDistance - (pos - begin)) / moveDistance\n\t\t};\n\t}\n}\n\nfunction scrollableInfo(element) {\n\tvar result = {\n\t\telement: element,\n\t\trect: (0, _utils.getVisibleRect)(element, element.getBoundingClientRect()),\n\t\tdescendants: [],\n\t\tinvalidate: invalidate,\n\t\taxis: null,\n\t\tdispose: dispose\n\t};\n\n\tfunction dispose() {\n\t\telement.removeEventListener('scroll', invalidate);\n\t}\n\n\tfunction invalidate() {\n\t\tresult.rect = (0, _utils.getVisibleRect)(element, element.getBoundingClientRect());\n\t\tresult.descendants.forEach(function (p) {\n\t\t\treturn p.invalidate();\n\t\t});\n\t}\n\n\telement.addEventListener('scroll', invalidate);\n\n\treturn result;\n}\n\nfunction getScrollableElements(containerElements) {\n\tvar scrollables = [];\n\tvar firstDescendentScrollable = null;\n\tcontainerElements.forEach(function (el) {\n\t\tvar current = el;\n\t\tfirstDescendentScrollable = null;\n\t\twhile (current) {\n\t\t\tvar scrollingAxis = (0, _utils.getScrollingAxis)(current);\n\t\t\tif (scrollingAxis) {\n\t\t\t\tif (!scrollables.some(function (p) {\n\t\t\t\t\treturn p.element === current;\n\t\t\t\t})) {\n\t\t\t\t\tvar info = scrollableInfo(current);\n\t\t\t\t\tif (firstDescendentScrollable) {\n\t\t\t\t\t\tinfo.descendants.push(firstDescendentScrollable);\n\t\t\t\t\t}\n\t\t\t\t\tfirstDescendentScrollable = info;\n\t\t\t\t\tif (scrollingAxis === 'xy') {\n\t\t\t\t\t\tscrollables.push(Object.assign({}, info, { axis: 'x' }));\n\t\t\t\t\t\tscrollables.push(Object.assign({}, info, { axis: 'y' }, { descendants: [] }));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscrollables.push(Object.assign({}, info, { axis: scrollingAxis }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.parentElement;\n\t\t}\n\t});\n\treturn scrollables;\n}\n\nfunction getScrollableAnimator(scrollableInfo) {\n\treturn Object.assign(scrollableInfo, createAnimator(scrollableInfo.element, scrollableInfo.axis));\n}\n\nfunction getWindowAnimators() {\n\tfunction getWindowRect() {\n\t\treturn {\n\t\t\tleft: 0, right: global.innerWidth, top: 0, bottom: global.innerHeight\n\t\t};\n\t}\n\n\treturn [Object.assign({ rect: getWindowRect(), axis: 'y' }, createAnimator(global)), Object.assign({ rect: getWindowRect(), axis: 'x' }, createAnimator(global, 'x'))];\n}\n\nexports.default = function (containers) {\n\tvar scrollablesInfo = getScrollableElements(containers.map(function (p) {\n\t\treturn p.element;\n\t}));\n\tvar animators = [].concat(_toConsumableArray(scrollablesInfo.map(getScrollableAnimator)), _toConsumableArray(getWindowAnimators()));\n\treturn function (_ref) {\n\t\tvar draggableInfo = _ref.draggableInfo,\n\t\t    reset = _ref.reset;\n\n\t\tif (animators.length) {\n\t\t\tif (reset) {\n\t\t\t\tanimators.forEach(function (p) {\n\t\t\t\t\treturn p.stop();\n\t\t\t\t});\n\t\t\t\tscrollablesInfo.forEach(function (p) {\n\t\t\t\t\treturn p.dispose();\n\t\t\t\t});\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tanimators.forEach(function (animator) {\n\t\t\t\tvar scrollParams = getAutoScrollInfo(draggableInfo.mousePosition, animator);\n\t\t\t\tif (scrollParams) {\n\t\t\t\t\tanimator.animate(scrollParams.direction, scrollParams.speedFactor * maxSpeed);\n\t\t\t\t} else {\n\t\t\t\t\tanimator.stop();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\treturn null;\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/dragscroller.js?");

/***/ }),

/***/ "./src/dropHandlers.js":
/*!*****************************!*\
  !*** ./src/dropHandlers.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.domDropHandler = domDropHandler;\nexports.reactDropHandler = reactDropHandler;\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nfunction domDropHandler(_ref) {\n\tvar element = _ref.element,\n\t    draggables = _ref.draggables,\n\t    layout = _ref.layout,\n\t    options = _ref.options;\n\n\treturn function (dropResult, onDrop) {\n\t\tvar removedIndex = dropResult.removedIndex,\n\t\t    addedIndex = dropResult.addedIndex,\n\t\t    droppedElement = dropResult.droppedElement;\n\n\t\tvar removedWrapper = null;\n\t\tif (removedIndex !== null) {\n\t\t\tremovedWrapper = (0, _utils.removeChildAt)(element, removedIndex);\n\t\t\tdraggables.splice(removedIndex, 1);\n\t\t}\n\n\t\tif (addedIndex !== null) {\n\t\t\tvar wrapper = global.document.createElement('div');\n\t\t\twrapper.className = '' + _constants.wrapperClass;\n\t\t\twrapper.appendChild(removedWrapper && removedWrapper.firstElementChild ? removedWrapper.firstElementChild : droppedElement);\n\t\t\twrapper[_constants.containersInDraggable] = [];\n\t\t\t(0, _utils.addChildAt)(element, wrapper, addedIndex);\n\t\t\tif (addedIndex >= draggables.length) {\n\t\t\t\tdraggables.push(wrapper);\n\t\t\t} else {\n\t\t\t\tdraggables.splice(addedIndex, 0, wrapper);\n\t\t\t}\n\t\t}\n\n\t\tif (onDrop) {\n\t\t\tonDrop(dropResult);\n\t\t}\n\t};\n}\n\nfunction reactDropHandler() {\n\tvar handler = function handler(_ref2) {\n\t\tvar element = _ref2.element,\n\t\t    draggables = _ref2.draggables,\n\t\t    layout = _ref2.layout,\n\t\t    options = _ref2.options;\n\n\t\treturn function (dropResult, onDrop) {\n\t\t\tif (onDrop) {\n\t\t\t\tonDrop(dropResult);\n\t\t\t}\n\t\t};\n\t};\n\n\treturn {\n\t\thandler: handler\n\t};\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/dropHandlers.js?");

/***/ }),

/***/ "./src/layoutManager.js":
/*!******************************!*\
  !*** ./src/layoutManager.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = layoutManager;\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar horizontalMap = {\n\tsize: 'offsetWidth',\n\tdistanceToParent: 'offsetLeft',\n\ttranslate: 'transform',\n\tbegin: 'left',\n\tend: 'right',\n\tdragPosition: 'x',\n\tscrollSize: 'scrollWidth',\n\toffsetSize: 'offsetWidth',\n\tscrollValue: 'scrollLeft',\n\tscale: 'scaleX',\n\tsetSize: 'width',\n\tsetters: {\n\t\t'translate': function translate(val) {\n\t\t\treturn 'translate3d(' + val + 'px, 0, 0)';\n\t\t}\n\t}\n};\n\nvar verticalMap = {\n\tsize: 'offsetHeight',\n\tdistanceToParent: 'offsetTop',\n\ttranslate: 'transform',\n\tbegin: 'top',\n\tend: 'bottom',\n\tdragPosition: 'y',\n\tscrollSize: 'scrollHeight',\n\toffsetSize: 'offsetHeight',\n\tscrollValue: 'scrollTop',\n\tscale: 'scaleY',\n\tsetSize: 'height',\n\tsetters: {\n\t\t'translate': function translate(val) {\n\t\t\treturn 'translate3d(0,' + val + 'px, 0)';\n\t\t}\n\t}\n};\n\nfunction orientationDependentProps(map) {\n\tfunction get(obj, prop) {\n\t\tvar mappedProp = map[prop];\n\t\treturn obj[mappedProp || prop];\n\t}\n\n\tfunction set(obj, prop, value) {\n\t\trequestAnimationFrame(function () {\n\t\t\tobj[map[prop]] = map.setters[prop] ? map.setters[prop](value) : value;\n\t\t});\n\t}\n\n\treturn { get: get, set: set };\n}\n\nfunction layoutManager(containerElement, orientation, _animationDuration) {\n\tcontainerElement[_constants.extraSizeForInsertion] = 0;\n\tvar animationDuration = _animationDuration;\n\tvar map = orientation === 'horizontal' ? horizontalMap : verticalMap;\n\tvar propMapper = orientationDependentProps(map);\n\tvar values = {\n\t\ttranslation: 0\n\t};\n\tvar registeredScrollListener = null;\n\n\tglobal.addEventListener('resize', function () {\n\t\tinvalidateContainerRectangles(containerElement);\n\t\t// invalidateContainerScale(containerElement);\n\t});\n\n\tsetTimeout(function () {\n\t\tinvalidate();\n\t}, 10);\n\t// invalidate();\n\n\tvar scrollListener = Utils.listenScrollParent(containerElement, function () {\n\t\tinvalidateContainerRectangles(containerElement);\n\t\tregisteredScrollListener && registeredScrollListener();\n\t});\n\tfunction invalidate() {\n\t\tinvalidateContainerRectangles(containerElement);\n\t\tinvalidateContainerScale(containerElement);\n\t}\n\n\tvar visibleRect = void 0;\n\tfunction invalidateContainerRectangles(containerElement) {\n\t\tvalues.rect = Utils.getContainerRect(containerElement);\n\t\tvalues.visibleRect = Utils.getVisibleRect(containerElement, values.rect);\n\t}\n\n\tfunction invalidateContainerScale(containerElement) {\n\t\tvar rect = containerElement.getBoundingClientRect();\n\t\tvalues.scaleX = containerElement.offsetWidth ? (rect.right - rect.left) / containerElement.offsetWidth : 1;\n\t\tvalues.scaleY = containerElement.offsetHeight ? (rect.bottom - rect.top) / containerElement.offsetHeight : 1;\n\t}\n\n\tfunction getContainerRectangles() {\n\t\treturn {\n\t\t\trect: values.rect,\n\t\t\tvisibleRect: values.visibleRect\n\t\t};\n\t}\n\n\tfunction getBeginEndOfDOMRect(rect) {\n\t\treturn {\n\t\t\tbegin: propMapper.get(rect, 'begin'),\n\t\t\tend: propMapper.get(rect, 'end')\n\t\t};\n\t}\n\n\tfunction getBeginEndOfContainer() {\n\t\tvar begin = propMapper.get(values.rect, 'begin') + values.translation;\n\t\tvar end = propMapper.get(values.rect, 'end') + values.translation;\n\t\treturn { begin: begin, end: end };\n\t}\n\n\tfunction getBeginEndOfContainerVisibleRect() {\n\t\tvar begin = propMapper.get(values.visibleRect, 'begin') + values.translation;\n\t\tvar end = propMapper.get(values.visibleRect, 'end') + values.translation;\n\t\treturn { begin: begin, end: end };\n\t}\n\n\tfunction getContainerScale() {\n\t\treturn { scaleX: values.scaleX, scaleY: values.scaleY };\n\t}\n\n\tfunction getSize(element) {\n\t\treturn propMapper.get(element, 'size') * propMapper.get(values, 'scale');\n\t}\n\n\tfunction getDistanceToOffsetParent(element) {\n\t\tvar distance = propMapper.get(element, 'distanceToParent') + (element[_constants.translationValue] || 0);\n\t\treturn distance * propMapper.get(values, 'scale');\n\t}\n\n\tfunction getBeginEnd(element) {\n\t\tvar begin = getDistanceToOffsetParent(element) + (propMapper.get(values.rect, 'begin') + values.translation) - propMapper.get(containerElement, 'scrollValue');\n\t\treturn {\n\t\t\tbegin: begin,\n\t\t\tend: begin + getSize(element) * propMapper.get(values, 'scale')\n\t\t};\n\t}\n\n\tfunction setSize(element, size) {\n\t\tpropMapper.set(element, 'setSize', size);\n\t}\n\n\tfunction getAxisValue(position) {\n\t\treturn propMapper.get(position, 'dragPosition');\n\t}\n\n\tfunction updateDescendantContainerRects(container) {\n\t\tcontainer.layout.invalidateRects();\n\t\tcontainer.onTranslated();\n\t\tif (container.getChildContainers()) {\n\t\t\tcontainer.getChildContainers().forEach(function (p) {\n\t\t\t\treturn updateDescendantContainerRects(p);\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setTranslation(element, translation) {\n\t\tif (!translation) {\n\t\t\telement.style.removeProperty('transform');\n\t\t} else {\n\t\t\tpropMapper.set(element.style, 'translate', translation);\n\t\t}\n\t\telement[_constants.translationValue] = translation;\n\n\t\tif (element[_constants.containersInDraggable]) {\n\t\t\tsetTimeout(function () {\n\t\t\t\telement[_constants.containersInDraggable].forEach(function (p) {\n\t\t\t\t\tupdateDescendantContainerRects(p);\n\t\t\t\t});\n\t\t\t}, animationDuration + 20);\n\t\t}\n\t}\n\n\tfunction getTranslation(element) {\n\t\treturn element[_constants.translationValue];\n\t}\n\n\tfunction setVisibility(element, isVisible) {\n\t\tif (element[_constants.visibilityValue] === undefined || element[_constants.visibilityValue] !== isVisible) {\n\t\t\tif (isVisible) {\n\t\t\t\telement.style.removeProperty('visibility');\n\t\t\t} else {\n\t\t\t\telement.style.visibility = 'hidden';\n\t\t\t}\n\t\t\telement[_constants.visibilityValue] = isVisible;\n\t\t}\n\t}\n\n\tfunction isVisible(element) {\n\t\treturn element[_constants.visibilityValue] === undefined || element[_constants.visibilityValue];\n\t}\n\n\tfunction isInVisibleRect(x, y) {\n\t\tvar _values$visibleRect = values.visibleRect,\n\t\t    left = _values$visibleRect.left,\n\t\t    top = _values$visibleRect.top,\n\t\t    right = _values$visibleRect.right,\n\t\t    bottom = _values$visibleRect.bottom;\n\n\t\t// if there is no wrapper in rect size will be 0 and wont accept any drop\n\t\t// so make sure at least there is 30px difference\n\n\t\tif (bottom - top < 2) {\n\t\t\tbottom = top + 30;\n\t\t}\n\t\tvar containerRect = values.rect;\n\t\tif (orientation === 'vertical') {\n\t\t\treturn x > containerRect.left && x < containerRect.right && y > top && y < bottom;\n\t\t} else {\n\t\t\treturn x > left && x < right && y > containerRect.top && y < containerRect.bottom;\n\t\t}\n\t}\n\n\tfunction setScrollListener(callback) {\n\t\tregisteredScrollListener = callback;\n\t}\n\n\tfunction getTopLeftOfElementBegin(begin) {\n\t\tvar top = 0;\n\t\tvar left = 0;\n\t\tif (orientation === 'horizontal') {\n\t\t\tleft = begin;\n\t\t\ttop = values.rect.top;\n\t\t} else {\n\t\t\tleft = values.rect.left;\n\t\t\ttop = begin;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top, left: left\n\t\t};\n\t}\n\n\tfunction getScrollSize(element) {\n\t\treturn propMapper.get(element, 'scrollSize');\n\t}\n\n\tfunction getScrollValue(element) {\n\t\treturn propMapper.get(element, 'scrollValue');\n\t}\n\n\tfunction setScrollValue(element, val) {\n\t\treturn propMapper.set(element, 'scrollValue', val);\n\t}\n\n\tfunction dispose() {\n\t\tif (scrollListener) {\n\t\t\tscrollListener.dispose();\n\t\t}\n\n\t\tif (visibleRect) {\n\t\t\tvisibleRect.parentNode.removeChild(visibleRect);\n\t\t\tvisibleRect = null;\n\t\t}\n\t}\n\n\tfunction getPosition(position) {\n\t\treturn isInVisibleRect(position.x, position.y) ? getAxisValue(position) : null;\n\t}\n\n\tfunction invalidateRects() {\n\t\tinvalidateContainerRectangles(containerElement);\n\t}\n\n\treturn {\n\t\tgetSize: getSize,\n\t\t//getDistanceToContainerBegining,\n\t\tgetContainerRectangles: getContainerRectangles,\n\t\tgetBeginEndOfDOMRect: getBeginEndOfDOMRect,\n\t\tgetBeginEndOfContainer: getBeginEndOfContainer,\n\t\tgetBeginEndOfContainerVisibleRect: getBeginEndOfContainerVisibleRect,\n\t\tgetBeginEnd: getBeginEnd,\n\t\tgetAxisValue: getAxisValue,\n\t\tsetTranslation: setTranslation,\n\t\tgetTranslation: getTranslation,\n\t\tsetVisibility: setVisibility,\n\t\tisVisible: isVisible,\n\t\tisInVisibleRect: isInVisibleRect,\n\t\tdispose: dispose,\n\t\tgetContainerScale: getContainerScale,\n\t\tsetScrollListener: setScrollListener,\n\t\tsetSize: setSize,\n\t\tgetTopLeftOfElementBegin: getTopLeftOfElementBegin,\n\t\tgetScrollSize: getScrollSize,\n\t\tgetScrollValue: getScrollValue,\n\t\tsetScrollValue: setScrollValue,\n\t\tinvalidate: invalidate,\n\t\tinvalidateRects: invalidateRects,\n\t\tgetPosition: getPosition\n\t};\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/layoutManager.js?");

/***/ }),

/***/ "./src/mediator.js":
/*!*************************!*\
  !*** ./src/mediator.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(/*! ./polyfills */ \"./src/polyfills.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _styles = __webpack_require__(/*! ./styles */ \"./src/styles.js\");\n\nvar _dragscroller = __webpack_require__(/*! ./dragscroller */ \"./src/dragscroller.js\");\n\nvar _dragscroller2 = _interopRequireDefault(_dragscroller);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar grabEvents = ['touchstart'];\nvar moveEvents = ['touchmove'];\nvar releaseEvents = ['touchend'];\n\nvar dragListeningContainers = null;\nvar grabbedElement = null;\nvar ghostInfo = null;\nvar draggableInfo = null;\nvar containers = [];\nvar isDragging = false;\nvar removedElement = null;\n\nvar handleDrag = null;\nvar handleScroll = null;\nvar sourceContainer = null;\nvar sourceContainerLockAxis = null;\nvar cursorStyleElement = null;\n\n// Utils.addClass(document.body, 'clearfix');\n\nvar isMobile = Utils.isMobile();\n\nfunction listenEvents() {\n  if (typeof window !== 'undefined') {\n    addGrabListeners();\n  }\n}\n\nfunction addGrabListeners() {\n  grabEvents.forEach(function (e) {\n    global.document.addEventListener(e, onMouseDown, { passive: false });\n  });\n}\n\nfunction addMoveListeners() {\n  moveEvents.forEach(function (e) {\n    global.document.addEventListener(e, onMouseMove, { passive: false });\n  });\n}\n\nfunction removeMoveListeners() {\n  moveEvents.forEach(function (e) {\n    global.document.removeEventListener(e, onMouseMove, { passive: false });\n  });\n}\n\nfunction addReleaseListeners() {\n  releaseEvents.forEach(function (e) {\n    global.document.addEventListener(e, onMouseUp, { passive: false });\n  });\n}\n\nfunction removeReleaseListeners() {\n  releaseEvents.forEach(function (e) {\n    global.document.removeEventListener(e, onMouseUp, { passive: false });\n  });\n}\n\nfunction getGhostParent() {\n  if (draggableInfo.ghostParent) {\n    return draggableInfo.ghostParent;\n  }\n\n  if (grabbedElement) {\n    return grabbedElement.parentElement || global.document.body;\n  } else {\n    return global.document.body;\n  }\n}\n\nfunction getGhostElement(wrapperElement, _ref, container, cursor) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  var _container$getScale = container.getScale(),\n      _container$getScale$s = _container$getScale.scaleX,\n      scaleX = _container$getScale$s === undefined ? 1 : _container$getScale$s,\n      _container$getScale$s2 = _container$getScale.scaleY,\n      scaleY = _container$getScale$s2 === undefined ? 1 : _container$getScale$s2;\n\n  var _wrapperElement$getBo = wrapperElement.getBoundingClientRect(),\n      left = _wrapperElement$getBo.left,\n      top = _wrapperElement$getBo.top,\n      right = _wrapperElement$getBo.right,\n      bottom = _wrapperElement$getBo.bottom;\n\n  var midX = left + (right - left) / 2;\n  var midY = top + (bottom - top) / 2;\n  var ghost = wrapperElement.cloneNode(true);\n  ghost.style.zIndex = 1000;\n  ghost.style.boxSizing = 'border-box';\n  ghost.style.position = 'fixed';\n  ghost.style.left = left + 'px';\n  ghost.style.top = top + 'px';\n  ghost.style.width = right - left + 'px';\n  ghost.style.height = bottom - top + 'px';\n  ghost.style.overflow = 'visible';\n  ghost.style.transition = null;\n  ghost.style.removeProperty('transition');\n  ghost.style.pointerEvents = 'none';\n\n  if (container.getOptions().dragClass) {\n    setTimeout(function () {\n      Utils.addClass(ghost.firstElementChild, container.getOptions().dragClass);\n      var dragCursor = global.getComputedStyle(ghost.firstElementChild).cursor;\n      cursorStyleElement = (0, _styles.addCursorStyleToBody)(dragCursor);\n    });\n  } else {\n    cursorStyleElement = (0, _styles.addCursorStyleToBody)(cursor);\n  }\n  Utils.addClass(ghost, container.getOptions().orientation);\n  Utils.addClass(ghost, constants.ghostClass);\n\n  return {\n    ghost: ghost,\n    centerDelta: { x: midX - x, y: midY - y },\n    positionDelta: { left: left - x, top: top - y }\n  };\n}\n\nfunction getDraggableInfo(draggableElement) {\n  var container = containers.filter(function (p) {\n    return draggableElement.parentElement === p.element;\n  })[0];\n  var draggableIndex = container.draggables.indexOf(draggableElement);\n  var getGhostParent = container.getOptions().getGhostParent;\n  return {\n    container: container,\n    element: draggableElement,\n    elementIndex: draggableIndex,\n    payload: container.getOptions().getChildPayload ? container.getOptions().getChildPayload(draggableIndex) : undefined,\n    targetElement: null,\n    position: { x: 0, y: 0 },\n    groupName: container.getOptions().groupName,\n    ghostParent: getGhostParent ? getGhostParent() : null\n  };\n}\n\nfunction handleDropAnimation(callback) {\n  function endDrop() {\n    Utils.removeClass(ghostInfo.ghost, 'animated');\n    ghostInfo.ghost.style.transitionDuration = null;\n    getGhostParent().removeChild(ghostInfo.ghost);\n    callback();\n  }\n\n  function animateGhostToPosition(_ref2, duration, dropClass) {\n    var top = _ref2.top,\n        left = _ref2.left;\n\n    Utils.addClass(ghostInfo.ghost, 'animated');\n    if (dropClass) {\n      Utils.addClass(ghostInfo.ghost.firstElementChild, dropClass);\n    }\n    ghostInfo.ghost.style.transitionDuration = duration + 'ms';\n    ghostInfo.ghost.style.left = left + 'px';\n    ghostInfo.ghost.style.top = top + 'px';\n    setTimeout(function () {\n      endDrop();\n    }, duration + 20);\n  }\n\n  function shouldAnimateDrop(options) {\n    return options.shouldAnimateDrop ? options.shouldAnimateDrop(draggableInfo.container.getOptions(), draggableInfo.payload) : true;\n  }\n\n  if (draggableInfo.targetElement) {\n    var container = containers.filter(function (p) {\n      return p.element === draggableInfo.targetElement;\n    })[0];\n    if (shouldAnimateDrop(container.getOptions())) {\n      var dragResult = container.getDragResult();\n      animateGhostToPosition(dragResult.shadowBeginEnd.rect, Math.max(150, container.getOptions().animationDuration / 2), container.getOptions().dropClass);\n    } else {\n      endDrop();\n    }\n  } else {\n    var _container = containers.filter(function (p) {\n      return p === draggableInfo.container;\n    })[0];\n\n    var _container$getOptions = _container.getOptions(),\n        behaviour = _container$getOptions.behaviour,\n        removeOnDropOut = _container$getOptions.removeOnDropOut;\n\n    if (behaviour === 'move' && !removeOnDropOut && _container.getDragResult()) {\n      var _container$getDragRes = _container.getDragResult(),\n          removedIndex = _container$getDragRes.removedIndex,\n          elementSize = _container$getDragRes.elementSize;\n\n      var layout = _container.layout;\n      // drag ghost to back\n      _container.getTranslateCalculator({\n        dragResult: {\n          removedIndex: removedIndex,\n          addedIndex: removedIndex,\n          elementSize: elementSize\n        }\n      });\n      var prevDraggableEnd = removedIndex > 0 ? layout.getBeginEnd(_container.draggables[removedIndex - 1]).end : layout.getBeginEndOfContainer().begin;\n      animateGhostToPosition(layout.getTopLeftOfElementBegin(prevDraggableEnd), _container.getOptions().animationDuration, _container.getOptions().dropClass);\n    } else {\n      Utils.addClass(ghostInfo.ghost, 'animated');\n      ghostInfo.ghost.style.transitionDuration = _container.getOptions().animationDuration + 'ms';\n      ghostInfo.ghost.style.opacity = '0';\n      ghostInfo.ghost.style.transform = 'scale(0.90)';\n      setTimeout(function () {\n        endDrop();\n      }, _container.getOptions().animationDuration);\n    }\n  }\n}\n\nvar handleDragStartConditions = function handleDragStartConditions() {\n  var startEvent = void 0;\n  var delay = void 0;\n  var clb = void 0;\n  var timer = null;\n  var moveThreshold = 1;\n  var maxMoveInDelay = 15;\n\n  function onMove(event) {\n    event.preventDefault();\n\n    var _getPointerEvent = getPointerEvent(event),\n        currentX = _getPointerEvent.clientX,\n        currentY = _getPointerEvent.clientY;\n    //console.log('dnd pointer event:', getPointerEvent(event))\n\n\n    if (!delay) {\n      console.log('dnd no delay');\n      if (Math.abs(startEvent.clientX - currentX) > moveThreshold || Math.abs(startEvent.clientY - currentY) > moveThreshold) {\n        return callCallback();\n      }\n    } else {\n      console.log('dnd has delay', Math.abs(startEvent.clientX - currentX) > maxMoveInDelay || Math.abs(startEvent.clientY - currentY) > maxMoveInDelay);\n      if (Math.abs(startEvent.clientX - currentX) > maxMoveInDelay || Math.abs(startEvent.clientY - currentY) > maxMoveInDelay) {\n        deregisterEvent();\n      }\n    }\n  }\n\n  function onUp() {\n    deregisterEvent();\n  }\n  function onHTMLDrag() {\n    deregisterEvent();\n  }\n\n  function registerEvents() {\n    if (delay) {\n      timer = setTimeout(callCallback, delay);\n    }\n\n    console.log('dnd register events');\n\n    moveEvents.forEach(function (e) {\n      return global.document.addEventListener(e, onMove);\n    }, {\n      passive: false\n    });\n    releaseEvents.forEach(function (e) {\n      return global.document.addEventListener(e, onUp);\n    }, {\n      passive: false\n    });\n    global.document.addEventListener('drag', onHTMLDrag, {\n      passive: false\n    });\n  }\n\n  function deregisterEvent() {\n    console.log('dnd deregister event');\n    clearTimeout(timer);\n    moveEvents.forEach(function (e) {\n      return global.document.removeEventListener(e, onMove);\n    }, {\n      passive: false\n    });\n    releaseEvents.forEach(function (e) {\n      return global.document.removeEventListener(e, onUp);\n    }, {\n      passive: false\n    });\n    global.document.removeEventListener('drag', onHTMLDrag, {\n      passive: false\n    });\n  }\n\n  function callCallback() {\n    console.log('dnd call callback');\n    clearTimeout(timer);\n    deregisterEvent();\n    clb();\n  }\n\n  return function (_startEvent, _delay, _clb) {\n    startEvent = getPointerEvent(_startEvent);\n    delay = typeof _delay === 'number' ? _delay : isMobile ? 500 : 0;\n    console.log('dnd delay', delay);\n    clb = _clb;\n\n    registerEvents();\n  };\n}();\n\nfunction onMouseDown(event) {\n  event.preventDefault();\n  var e = getPointerEvent(event);\n  console.log('dnd mouse down event', e);\n  if (!isDragging && (e.button === undefined || e.button === 0)) {\n    grabbedElement = Utils.getParent(e.target, '.' + constants.wrapperClass);\n    console.log('dnd grabbed element', grabbedElement);\n    if (grabbedElement) {\n      var containerElement = Utils.getParent(grabbedElement, '.' + constants.containerClass);\n      var container = containers.filter(function (p) {\n        return p.element === containerElement;\n      })[0];\n      var dragHandleSelector = container.getOptions().dragHandleSelector;\n      var nonDragAreaSelector = container.getOptions().nonDragAreaSelector;\n\n      var startDrag = true;\n      if (dragHandleSelector && !Utils.getParent(e.target, dragHandleSelector)) {\n        startDrag = false;\n      }\n\n      if (nonDragAreaSelector && Utils.getParent(e.target, nonDragAreaSelector)) {\n        startDrag = false;\n      }\n\n      console.log('dnd ', 'onMouseDown', 'startDrag:', startDrag);\n\n      if (startDrag) {\n        handleDragStartConditions(e, container.getOptions().dragBeginDelay, function () {\n          Utils.clearSelection();\n          initiateDrag(e, Utils.getElementCursor(event.target));\n          addMoveListeners();\n          addReleaseListeners();\n        });\n      }\n    }\n  }\n}\n\nfunction onMouseUp() {\n  console.log('dnd onmouse up');\n  removeMoveListeners();\n  removeReleaseListeners();\n  handleScroll({ reset: true });\n  if (cursorStyleElement) {\n    console.log('dnd cursor style element', cursorStyleElement);\n    (0, _styles.removeStyle)(cursorStyleElement);\n    cursorStyleElement = null;\n  }\n  if (draggableInfo) {\n    handleDropAnimation(function () {\n      Utils.removeClass(global.document.body, constants.disbaleTouchActions);\n      Utils.removeClass(global.document.body, constants.noUserSelectClass);\n      fireOnDragStartEnd(false);\n      (dragListeningContainers || []).forEach(function (p) {\n        p.handleDrop(draggableInfo);\n      });\n\n      dragListeningContainers = null;\n      grabbedElement = null;\n      ghostInfo = null;\n      draggableInfo = null;\n      isDragging = false;\n      sourceContainer = null;\n      sourceContainerLockAxis = null;\n      handleDrag = null;\n    });\n  }\n}\n\nfunction getPointerEvent(e) {\n  return e.touches ? e.touches[0] : e;\n}\n\nfunction dragHandler(dragListeningContainers) {\n  var targetContainers = dragListeningContainers;\n  return function (draggableInfo) {\n    console.log('dnd draggable Info', draggableInfo);\n    var containerBoxChanged = false;\n    targetContainers.forEach(function (p) {\n      var dragResult = p.handleDrag(draggableInfo);\n      containerBoxChanged |= dragResult.containerBoxChanged || false;\n      dragResult.containerBoxChanged = false;\n    });\n    handleScroll({ draggableInfo: draggableInfo });\n\n    if (containerBoxChanged) {\n      containerBoxChanged = false;\n      setTimeout(function () {\n        containers.forEach(function (p) {\n          p.layout.invalidateRects();\n          p.onTranslated();\n        });\n      }, 10);\n    }\n  };\n}\n\nfunction getScrollHandler(container, dragListeningContainers) {\n  if (container.getOptions().autoScrollEnabled) {\n    return (0, _dragscroller2.default)(dragListeningContainers);\n  } else {\n    return function () {\n      return null;\n    };\n  }\n}\n\nfunction fireOnDragStartEnd(isStart) {\n  containers.forEach(function (p) {\n    var fn = isStart ? p.getOptions().onDragStart : p.getOptions().onDragEnd;\n    if (fn) {\n      var options = {\n        isSource: p === draggableInfo.container,\n        payload: draggableInfo.payload\n      };\n      if (p.isDragRelevant(draggableInfo.container, draggableInfo.payload)) {\n        options.willAcceptDrop = true;\n      } else {\n        options.willAcceptDrop = false;\n      }\n      fn(options);\n    }\n  });\n}\n\nfunction initiateDrag(position, cursor) {\n  isDragging = true;\n  var container = containers.filter(function (p) {\n    return grabbedElement.parentElement === p.element;\n  })[0];\n  container.setDraggables();\n  sourceContainer = container;\n  sourceContainerLockAxis = container.getOptions().lockAxis ? container.getOptions().lockAxis.toLowerCase() : null;\n\n  draggableInfo = getDraggableInfo(grabbedElement);\n  ghostInfo = getGhostElement(grabbedElement, { x: position.clientX, y: position.clientY }, draggableInfo.container, cursor);\n  draggableInfo.position = {\n    x: position.clientX + ghostInfo.centerDelta.x,\n    y: position.clientY + ghostInfo.centerDelta.y\n  };\n  draggableInfo.mousePosition = {\n    x: position.clientX,\n    y: position.clientY\n  };\n\n  Utils.addClass(global.document.body, constants.disbaleTouchActions);\n  Utils.addClass(global.document.body, constants.noUserSelectClass);\n\n  dragListeningContainers = containers.filter(function (p) {\n    return p.isDragRelevant(container, draggableInfo.payload);\n  });\n  handleDrag = dragHandler(dragListeningContainers);\n  if (handleScroll) {\n    handleScroll({ reset: true });\n  }\n\n  console.log('dnd initiate drag', position, 'cursor', cursor, 'handleScroll', handleScroll);\n\n  handleScroll = getScrollHandler(container, dragListeningContainers);\n  dragListeningContainers.forEach(function (p) {\n    return p.prepareDrag(p, dragListeningContainers);\n  });\n  fireOnDragStartEnd(true);\n  handleDrag(draggableInfo);\n  getGhostParent().appendChild(ghostInfo.ghost);\n}\n\nfunction onMouseMove(event) {\n  event.preventDefault();\n  var e = getPointerEvent(event);\n  if (!draggableInfo) {\n    initiateDrag(e, Utils.getElementCursor(event.target));\n  } else {\n    // just update ghost position && draggableInfo position\n    if (sourceContainerLockAxis) {\n      if (sourceContainerLockAxis === 'y') {\n        ghostInfo.ghost.style.top = e.clientY + ghostInfo.positionDelta.top + 'px';\n        draggableInfo.position.y = e.clientY + ghostInfo.centerDelta.y;\n        draggableInfo.mousePosition.y = e.clientY;\n      } else if (sourceContainerLockAxis === 'x') {\n        ghostInfo.ghost.style.left = e.clientX + ghostInfo.positionDelta.left + 'px';\n        draggableInfo.position.x = e.clientX + ghostInfo.centerDelta.x;\n        draggableInfo.mousePosition.x = e.clientX;\n      }\n    } else {\n      ghostInfo.ghost.style.left = e.clientX + ghostInfo.positionDelta.left + 'px';\n      ghostInfo.ghost.style.top = e.clientY + ghostInfo.positionDelta.top + 'px';\n      draggableInfo.position.x = e.clientX + ghostInfo.centerDelta.x;\n      draggableInfo.position.y = e.clientY + ghostInfo.centerDelta.y;\n      draggableInfo.mousePosition.x = e.clientX;\n      draggableInfo.mousePosition.y = e.clientY;\n    }\n\n    handleDrag(draggableInfo);\n  }\n}\n\nfunction Mediator() {\n  listenEvents();\n  return {\n    register: function register(container) {\n      containers.push(container);\n    },\n    unregister: function unregister(container) {\n      containers.splice(containers.indexOf(container), 1);\n    }\n  };\n}\n\n(0, _styles.addStyleToHead)();\n\nexports.default = Mediator();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/mediator.js?");

/***/ }),

/***/ "./src/polyfills.js":
/*!**************************!*\
  !*** ./src/polyfills.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n(function (constructor) {\n  if (constructor && constructor.prototype && !constructor.prototype.matches) {\n    constructor.prototype.matches = constructor.prototype.matchesSelector || constructor.prototype.mozMatchesSelector || constructor.prototype.msMatchesSelector || constructor.prototype.oMatchesSelector || constructor.prototype.webkitMatchesSelector || function (s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n          i = matches.length;\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n  }\n})(global.Node || global.Element);\n\n// Overwrites native 'firstElementChild' prototype.\n// Adds Document & DocumentFragment support for IE9 & Safari.\n// Returns array instead of HTMLCollection.\n(function (constructor) {\n  if (constructor && constructor.prototype && constructor.prototype.firstElementChild == null) {\n    Object.defineProperty(constructor.prototype, \"firstElementChild\", {\n      get: function get() {\n        var node,\n            nodes = this.childNodes,\n            i = 0;\n        while (node = nodes[i++]) {\n          if (node.nodeType === 1) {\n            return node;\n          }\n        }\n        return null;\n      }\n    });\n  }\n})(global.Node || global.Element);\n\n// Production steps of ECMA-262, Edition 5, 15.4.4.17\n// Reference: http://es5.github.io/#x15.4.4.17\nif (!Array.prototype.some) {\n  Array.prototype.some = function (fun /*, thisArg*/) {\n    \"use strict\";\n\n    if (this == null) {\n      throw new TypeError(\"Array.prototype.some called on null or undefined\");\n    }\n\n    if (typeof fun !== \"function\") {\n      throw new TypeError();\n    }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    for (var i = 0; i < len; i++) {\n      if (i in t && fun.call(thisArg, t[i], i, t)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/polyfills.js?");

/***/ }),

/***/ "./src/styles.js":
/*!***********************!*\
  !*** ./src/styles.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.removeStyle = exports.addCursorStyleToBody = exports.addStyleToHead = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _css;\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar verticalWrapperClass = {\n\t'overflow': 'hidden',\n\t'display': 'block'\n};\n\nvar horizontalWrapperClass = {\n\t'height': '100%',\n\t'display': 'inline-block',\n\t'vertical-align': 'top',\n\t'white-space': 'normal'\n};\n\nvar stretcherElementHorizontalClass = {\n\t'display': 'inline-block'\n};\n\nvar css = (_css = {}, _defineProperty(_css, '.' + constants.containerClass, {\n\t'position': 'relative'\n}), _defineProperty(_css, '.' + constants.containerClass + ' *', {\n\t'box-sizing': 'border-box'\n}), _defineProperty(_css, '.' + constants.containerClass + '.horizontal', {\n\t'white-space': 'nowrap'\n}), _defineProperty(_css, '.' + constants.containerClass + '.horizontal > .' + constants.stretcherElementClass, stretcherElementHorizontalClass), _defineProperty(_css, '.' + constants.containerClass + '.horizontal > .' + constants.wrapperClass, horizontalWrapperClass), _defineProperty(_css, '.' + constants.containerClass + '.vertical > .' + constants.wrapperClass, verticalWrapperClass), _defineProperty(_css, '.' + constants.wrapperClass, {\n\t// 'overflow': 'hidden'\n}), _defineProperty(_css, '.' + constants.wrapperClass + '.horizontal', horizontalWrapperClass), _defineProperty(_css, '.' + constants.wrapperClass + '.vertical', verticalWrapperClass), _defineProperty(_css, '.' + constants.wrapperClass + '.animated', {\n\t'transition': 'transform ease'\n}), _defineProperty(_css, '.' + constants.ghostClass + ' *', {\n\t//'perspective': '800px',\n\t'box-sizing': 'border-box'\n}), _defineProperty(_css, '.' + constants.ghostClass + '.animated', {\n\t'transition': 'all ease-in-out'\n}), _defineProperty(_css, '.' + constants.disbaleTouchActions + ' *', {\n\t'touch-actions': 'none',\n\t'-ms-touch-actions': 'none'\n}), _defineProperty(_css, '.' + constants.noUserSelectClass + ' *', {\n\t'-webkit-touch-callout': 'none',\n\t'-webkit-user-select': 'none',\n\t'-khtml-user-select': 'none',\n\t'-moz-user-select': 'none',\n\t'-ms-user-select': 'none',\n\t'user-select': 'none'\n}), _css);\n\nfunction convertToCssString(css) {\n\treturn Object.keys(css).reduce(function (styleString, propName) {\n\t\tvar propValue = css[propName];\n\t\tif ((typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) === 'object') {\n\t\t\treturn '' + styleString + propName + '{' + convertToCssString(propValue) + '}';\n\t\t}\n\t\treturn '' + styleString + propName + ':' + propValue + ';';\n\t}, '');\n}\n\nfunction addStyleToHead() {\n\tif (typeof window !== 'undefined') {\n\t\tvar head = global.document.head || global.document.getElementsByTagName(\"head\")[0];\n\t\tvar style = global.document.createElement(\"style\");\n\t\tvar cssString = convertToCssString(css);\n\t\tstyle.type = 'text/css';\n\t\tif (style.styleSheet) {\n\t\t\tstyle.styleSheet.cssText = cssString;\n\t\t} else {\n\t\t\tstyle.appendChild(global.document.createTextNode(cssString));\n\t\t}\n\n\t\thead.appendChild(style);\n\t}\n}\n\nfunction addCursorStyleToBody(cursor) {\n\tif (cursor && typeof window !== 'undefined') {\n\t\tvar head = global.document.head || global.document.getElementsByTagName(\"head\")[0];\n\t\tvar style = global.document.createElement(\"style\");\n\t\tvar cssString = convertToCssString({\n\t\t\t'body *': {\n\t\t\t\tcursor: cursor + ' !important'\n\t\t\t}\n\t\t});\n\t\tstyle.type = 'text/css';\n\t\tif (style.styleSheet) {\n\t\t\tstyle.styleSheet.cssText = cssString;\n\t\t} else {\n\t\t\tstyle.appendChild(global.document.createTextNode(cssString));\n\t\t}\n\n\t\thead.appendChild(style);\n\n\t\treturn style;\n\t}\n\n\treturn null;\n}\n\nfunction removeStyle(styleElement) {\n\tif (styleElement && typeof window !== 'undefined') {\n\t\tvar head = global.document.head || global.document.getElementsByTagName(\"head\")[0];\n\t\thead.removeChild(styleElement);\n\t}\n}\n\nexports.addStyleToHead = addStyleToHead;\nexports.addCursorStyleToBody = addCursorStyleToBody;\nexports.removeStyle = removeStyle;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/styles.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar getIntersection = exports.getIntersection = function getIntersection(rect1, rect2) {\n  return {\n    left: Math.max(rect1.left, rect2.left),\n    top: Math.max(rect1.top, rect2.top),\n    right: Math.min(rect1.right, rect2.right),\n    bottom: Math.min(rect1.bottom, rect2.bottom)\n  };\n};\n\nvar getIntersectionOnAxis = exports.getIntersectionOnAxis = function getIntersectionOnAxis(rect1, rect2, axis) {\n  if (axis === \"x\") {\n    return {\n      left: Math.max(rect1.left, rect2.left),\n      top: rect1.top,\n      right: Math.min(rect1.right, rect2.right),\n      bottom: rect1.bottom\n    };\n  } else {\n    return {\n      left: rect1.left,\n      top: Math.max(rect1.top, rect2.top),\n      right: rect1.right,\n      bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n  }\n};\n\nvar getContainerRect = exports.getContainerRect = function getContainerRect(element) {\n  var _rect = element.getBoundingClientRect();\n  var rect = {\n    left: _rect.left,\n    right: _rect.right + 10,\n    top: _rect.top,\n    bottom: _rect.bottom\n  };\n\n  if (hasBiggerChild(element, \"x\") && !isScrollingOrHidden(element, \"x\")) {\n    var width = rect.right - rect.left;\n    rect.right = rect.right + element.scrollWidth - width;\n  }\n\n  if (hasBiggerChild(element, \"y\") && !isScrollingOrHidden(element, \"y\")) {\n    var height = rect.bottom - rect.top;\n    rect.bottom = rect.bottom + element.scrollHeight - height;\n  }\n\n  return rect;\n};\n\nvar getScrollingAxis = exports.getScrollingAxis = function getScrollingAxis(element) {\n  var style = global.getComputedStyle(element);\n  var overflow = style[\"overflow\"];\n  var general = overflow === \"auto\" || overflow === \"scroll\";\n  if (general) return \"xy\";\n  var overFlowX = style[\"overflow-x\"];\n  var xScroll = overFlowX === \"auto\" || overFlowX === \"scroll\";\n  var overFlowY = style[\"overflow-y\"];\n  var yScroll = overFlowY === \"auto\" || overFlowY === \"scroll\";\n\n  return \"\" + (xScroll ? \"x\" : \"\") + (yScroll ? \"y\" : \"\") || null;\n};\n\nvar isScrolling = exports.isScrolling = function isScrolling(element, axis) {\n  var style = global.getComputedStyle(element);\n  var overflow = style[\"overflow\"];\n  var overFlowAxis = style[\"overflow-\" + axis];\n  var general = overflow === \"auto\" || overflow === \"scroll\";\n  var dimensionScroll = overFlowAxis === \"auto\" || overFlowAxis === \"scroll\";\n  return general || dimensionScroll;\n};\n\nvar isScrollingOrHidden = exports.isScrollingOrHidden = function isScrollingOrHidden(element, axis) {\n  var style = global.getComputedStyle(element);\n  var overflow = style[\"overflow\"];\n  var overFlowAxis = style[\"overflow-\" + axis];\n  var general = overflow === \"auto\" || overflow === \"scroll\" || overflow === \"hidden\";\n  var dimensionScroll = overFlowAxis === \"auto\" || overFlowAxis === \"scroll\" || overFlowAxis === \"hidden\";\n  return general || dimensionScroll;\n};\n\nvar hasBiggerChild = exports.hasBiggerChild = function hasBiggerChild(element, axis) {\n  if (axis === \"x\") {\n    return element.scrollWidth > element.clientWidth;\n  } else {\n    return element.scrollHeight > element.clientHeight;\n  }\n};\n\nvar hasScrollBar = exports.hasScrollBar = function hasScrollBar(element, axis) {\n  return hasBiggerChild(element, axis) && isScrolling(element, axis);\n};\n\nvar getVisibleRect = exports.getVisibleRect = function getVisibleRect(element, elementRect) {\n  var currentElement = element;\n  var rect = elementRect || getContainerRect(element);\n  currentElement = element.parentElement;\n  while (currentElement) {\n    if (hasBiggerChild(currentElement, \"x\") && isScrollingOrHidden(currentElement, \"x\")) {\n      rect = getIntersectionOnAxis(rect, currentElement.getBoundingClientRect(), \"x\");\n    }\n\n    if (hasBiggerChild(currentElement, \"y\") && isScrollingOrHidden(currentElement, \"y\")) {\n      rect = getIntersectionOnAxis(rect, currentElement.getBoundingClientRect(), \"y\");\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return rect;\n};\n\nvar listenScrollParent = exports.listenScrollParent = function listenScrollParent(element, clb) {\n  var scrollers = [];\n  var dispose = function dispose() {\n    scrollers.forEach(function (p) {\n      p.removeEventListener(\"scroll\", clb);\n    });\n    global.removeEventListener(\"scroll\", clb);\n  };\n\n  setTimeout(function () {\n    var currentElement = element;\n    while (currentElement) {\n      if (isScrolling(currentElement, \"x\") || isScrolling(currentElement, \"y\")) {\n        currentElement.addEventListener(\"scroll\", clb);\n        scrollers.push(currentElement);\n      }\n      currentElement = currentElement.parentElement;\n    }\n\n    global.addEventListener(\"scroll\", clb);\n  }, 10);\n\n  return {\n    dispose: dispose\n  };\n};\n\nvar hasParent = exports.hasParent = function hasParent(element, parent) {\n  var current = element;\n  while (current) {\n    if (current === parent) {\n      return true;\n    }\n    current = current.parentElement;\n  }\n  return false;\n};\n\nvar getParent = exports.getParent = function getParent(element, selector) {\n  var current = element;\n  while (current) {\n    if (current.matches(selector)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n\n  return null;\n};\n\nvar hasClass = exports.hasClass = function hasClass(element, cls) {\n  return element.className.split(\" \").map(function (p) {\n    return p;\n  }).indexOf(cls) > -1;\n};\n\nvar addClass = exports.addClass = function addClass(element, cls) {\n  if (element) {\n    element.className = element.className || '';\n    var classes = element.className.split(\" \").filter(function (p) {\n      return p;\n    });\n    if (classes.indexOf(cls) === -1) {\n      classes.unshift(cls);\n      element.className = classes.join(\" \");\n    }\n  }\n};\n\nvar removeClass = exports.removeClass = function removeClass(element, cls) {\n  if (element) {\n    var classes = element.className.split(\" \").filter(function (p) {\n      return p && p !== cls;\n    });\n    element.className = classes.join(\" \");\n  }\n};\n\nvar debounce = exports.debounce = function debounce(fn, delay, immediate) {\n  var timer = null;\n  return function () {\n    for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n    if (immediate && !timer) {\n      fn.call.apply(fn, [undefined].concat(params));\n    } else {\n      timer = setTimeout(function () {\n        timer = null;\n        fn.call.apply(fn, [undefined].concat(params));\n      }, delay);\n    }\n  };\n};\n\nvar removeChildAt = exports.removeChildAt = function removeChildAt(parent, index) {\n  return parent.removeChild(parent.children[index]);\n};\n\nvar addChildAt = exports.addChildAt = function addChildAt(parent, child, index) {\n  if (index >= parent.children.lenght) {\n    parent.appendChild(child);\n  } else {\n    parent.insertBefore(child, parent.children[index]);\n  }\n};\n\nvar isMobile = exports.isMobile = function isMobile() {\n  if (typeof window !== 'undefined') {\n    if (global.navigator.userAgent.match(/Android/i) || global.navigator.userAgent.match(/webOS/i) || global.navigator.userAgent.match(/iPhone/i) || global.navigator.userAgent.match(/iPad/i) || global.navigator.userAgent.match(/iPod/i) || global.navigator.userAgent.match(/BlackBerry/i) || global.navigator.userAgent.match(/Windows Phone/i) ||\n    // iPad OS / iOS 13 on iPad\n    global.navigator.platform === 'MacIntel' && global.navigator.maxTouchPoints > 1) {\n      console.log('dnd is mobile:', true, 'useragent:', global.navigator.userAgent);\n      return true;\n    } else {\n      console.log('dnd is mobile:', false, 'useragent:', global.navigator.userAgent);\n      return false;\n    }\n  }\n  console.log('dnd is mobile:', false);\n  return false;\n};\n\nvar clearSelection = exports.clearSelection = function clearSelection() {\n  if (global.getSelection) {\n    if (global.getSelection().empty) {\n      // Chrome\n      global.getSelection().empty();\n    } else if (global.getSelection().removeAllRanges) {\n      // Firefox\n      global.getSelection().removeAllRanges();\n    }\n  } else if (global.document.selection) {\n    // IE?\n    global.document.selection.empty();\n  }\n};\n\nvar getElementCursor = exports.getElementCursor = function getElementCursor(element) {\n  if (element) {\n    var style = global.getComputedStyle(element);\n    if (style) {\n      return style.cursor;\n    }\n  }\n\n  return null;\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://SmoothDnD/./src/utils.js?");

/***/ })

/******/ });
});